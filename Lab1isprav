#define WINVER 0x0502
#include <iostream>
#include <windows.h>
#include <stdio.h>
#include <tchar.h>



#define INFO_BUFFER_SIZE 32767
#define BUFSIZE MAX_PATH
#define MAX_KEY_LENGTH 255



int main()
{
//Пункт 2
    LARGE_INTEGER lpPerformanceCount_s;

    QueryPerformanceCounter(&lpPerformanceCount_s);
// Пункт 1.1
    OSVERSIONINFO lpVersionInformation = {0};
    lpVersionInformation.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&lpVersionInformation);
    unsigned verh=lpVersionInformation.dwMajorVersion;
    unsigned niz=lpVersionInformation.dwMinorVersion;
    std::cout<<"1.1. \nWindows version : "<<verh<<"."<<niz<<"\n";
// Пунтк 1.2
    TCHAR  lpBuffer[INFO_BUFFER_SIZE];
    DWORD  nSize = INFO_BUFFER_SIZE;
    GetSystemDirectory(lpBuffer, nSize);
    std::cout<<"\n1.2.  \nSystem directory : "<<lpBuffer<<"\n";
// Пункт 1.3
    GetComputerName(lpBuffer,&nSize);
    std::cout<<"\n1.3.  \nComputer Name : "<<lpBuffer<<"\n";
    nSize = INFO_BUFFER_SIZE;
    GetUserName(lpBuffer,&nSize);
    std::cout<<"User Name : "<<lpBuffer<<"\n";
// Пункт 1.4
    CHAR name[MAX_PATH+1];
    CHAR path[MAX_PATH+1];
    DWORD len=INFO_BUFFER_SIZE;
    __int64 total, free;

    std::cout<<"\n1.4.\n";

    HANDLE search = FindFirstVolume(name, MAX_PATH);
    do {
        GetVolumePathNamesForVolumeName(name,path,MAX_PATH+1,&len);
        GetDiskFreeSpaceEx(path,(PULARGE_INTEGER)&free,(PULARGE_INTEGER)&total,NULL);
           std::cout<<"\nThe service name of the volume: "<<name<<"\nThe first path: "<< path;
        if ((GetDiskFreeSpaceEx(path,(PULARGE_INTEGER)&free,(PULARGE_INTEGER)&total,NULL)!=0))
        {
            std::cout<<"\nTotal space : "<<total<<"\tFree space : "<<free<<"\n";
        }
        else
            {
            std::cout<<"\nNo avaible data about space\n";
            }
        }
    while (FindNextVolume(search, name, MAX_PATH));
    FindVolumeClose(search);
// Пункт 1.5
    TCHAR lpValueName[INFO_BUFFER_SIZE+1];
    DWORD lpcchValueName = INFO_BUFFER_SIZE;
    HKEY phkResult;
    DWORD dwIndex = 0;
    TCHAR lpData[INFO_BUFFER_SIZE+1];
    DWORD lpcbData = INFO_BUFFER_SIZE+1;

    std::cout<<"\n1.5.\n";

    if ((RegOpenKeyEx(HKEY_CURRENT_USER, "Software\\Microsoft\\Windows\\CurrentVersion\\Run",NULL, KEY_ALL_ACCESS, &phkResult)) == ERROR_SUCCESS)
    {
        std::cout << "\nThe registry key was successfully opened\nList of programs that are launched at system startup: \n";
        while (true) {
            DWORD lpcchValueName=sizeof(lpValueName);
            DWORD Regenum = RegEnumValue(phkResult, dwIndex, lpValueName, &lpcchValueName, NULL, NULL, NULL, NULL);
            if (Regenum == ERROR_SUCCESS)
            {
            std::cout <<dwIndex+1<<" : "<< lpValueName << "\n";
            dwIndex=dwIndex+1;
            lpValueName[INFO_BUFFER_SIZE+1];
            }
            else
            {
                if (Regenum==ERROR_NO_MORE_ITEMS)
                {
                    std::cout<<"\nNo more avaible information\n";
                }
                else
                {
                    std::cout<<"\nThe function failed\n";
                }
              break;
            }
            }
        }
    RegCloseKey(phkResult);


    LARGE_INTEGER lpPerformanceCount_f;
    LARGE_INTEGER lpFrequency;
    QueryPerformanceCounter(&lpPerformanceCount_f);
    QueryPerformanceFrequency(&lpFrequency);
    printf("\n2\nCPU operating frequency = %u Hz\n", lpFrequency);
    double usec = 1e6 * ((double)lpPerformanceCount_f.QuadPart - (double)lpPerformanceCount_s.QuadPart) / (double)lpFrequency.QuadPart;
    std::cout<<"Number of program execution cycles = "<<usec<<" ns\n";
    return 0;
}
